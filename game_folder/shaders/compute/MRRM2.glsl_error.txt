#version 430
//4*4 ray bundle
#define group_size 8
#define block_size 64

layout(local_size_x = group_size, local_size_y = group_size) in;
layout(rgba32f, binding = 0) uniform image2D DE_input; 
layout(rgba32f, binding = 1) uniform image2D var_input; 
layout(rgba32f, binding = 2) uniform image2D DE_output; 
layout(rgba32f, binding = 3) uniform image2D var_output; 

//make all the local distance estimator spheres shared
shared vec4 de_sph[group_size][group_size]; 


struct ray
{
	vec3 pos;
	vec3 dir;
};		

struct gl_camera
{
	vec3 position;
	vec3 dirx;
	vec3 diry;
	vec3 dirz;
	vec2 resolution;
	float aspect_ratio;
	float FOV;
	float focus;
	float bokeh;
	float exposure;
	float mblur;
	float speckle;
	float size;
	int stepN;
	int step;
};


ivec2 getGpos(int index)
{
	int y = index/group_size;
	int x = index%group_size;
	return ivec2(x,y);
}

uniform gl_camera Camera;
float fovray;

ray get_ray(vec2 screen_pos)
{
	vec2 shift = Camera.FOV*(2.f*screen_pos - 1.f)*vec2(Camera.aspect_ratio, 1.f);
	ray cray;
	cray.pos = Camera.position;
	cray.dir = normalize(Camera.dirx*shift.x + Camera.diry*shift.y + Camera.dirz);
	fovray = Camera.FOV/Camera.resolution.x; //pixel FOV
	return cray;
}

#define COL col_scene
#define DE de_scene

uniform float iFracScale;
uniform float iFracAng1;
uniform float iFracAng2;
uniform vec3 iFracShift;
uniform vec3 iFracCol;
uniform vec3 iMarblePos;
uniform float iMarbleRad;
uniform float iFlagScale;
uniform vec3 iFlagPos;
#define FRACTAL_ITER 16

///Original MM distance estimators

float s1 = sin(iFracAng1), c1 = cos(iFracAng1), s2 = sin(iFracAng2), c2 = cos(iFracAng2);

//##########################################
//   Space folding
//##########################################
void planeFold(inout vec4 z, vec3 n, float d) {
	z.xyz -= 2.0 * min(0.0, dot(z.xyz, n) - d) * n;
}
void sierpinskiFold(inout vec4 z) {
	z.xy -= min(z.x + z.y, 0.0);
	z.xz -= min(z.x + z.z, 0.0);
	z.yz -= min(z.y + z.z, 0.0);
}
void mengerFold(inout vec4 z) {
	float a = min(z.x - z.y, 0.0);
	z.x -= a;
	z.y += a;
	a = min(z.x - z.z, 0.0);
	z.x -= a;
	z.z += a;
	a = min(z.y - z.z, 0.0);
	z.y -= a;
	z.z += a;
}
void boxFold(inout vec4 z, vec3 r) {
	z.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;
}
void rotX(inout vec4 z, float s, float c) {
	z.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);
}
void rotY(inout vec4 z, float s, float c) {
	z.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);
}
void rotZ(inout vec4 z, float s, float c) {
	z.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);
}
void rotX(inout vec4 z, float a) {
	rotX(z, sin(a), cos(a));
}
void rotY(inout vec4 z, float a) {
	rotY(z, sin(a), cos(a));
}
void rotZ(inout vec4 z, float a) {
	rotZ(z, sin(a), cos(a));
}

//##########################################
//   Primitive DEs
//##########################################
float de_sphere(vec4 p, float r) {
	return (length(p.xyz) - r) / p.w;
}
float de_box(vec4 p, vec3 s) {
	vec3 a = abs(p.xyz) - s;
	return (min(max(max(a.x, a.y), a.z), 0.0) + length(max(a, 0.0))) / p.w;
}
float de_tetrahedron(vec4 p, float r) {
	float md = max(max(-p.x - p.y - p.z, p.x + p.y - p.z),
				max(-p.x + p.y + p.z, p.x - p.y + p.z));
	return (md - r) / (p.w * sqrt(3.0));
}
float de_capsule(vec4 p, float h, float r) {
	p.y -= clamp(p.y, -h, h);
	return (length(p.xyz) - r) / p.w;
}

//##########################################
//   Main DEs
//##########################################
float de_fractal(vec4 p)
{
	for (int i = 0; i < FRACTAL_ITER; ++i) {
		p.xyz = abs(p.xyz);
		rotZ(p, s1, c1);
		mengerFold(p);
		rotX(p, s2, c2);
		p *= iFracScale;
		p.xyz += iFracShift;
	}
	return de_box(p, vec3(6.0));
}

vec4 col_fractal(vec4 p) 
{
	vec3 orbit = vec3(0.0);
	for (int i = 0; i < FRACTAL_ITER; ++i) {
		p.xyz = abs(p.xyz);
		rotZ(p, s1, c1);
		mengerFold(p);
		rotX(p, s2, c2);
		p *= iFracScale;
		p.xyz += iFracShift;
		orbit = max(orbit, p.xyz*iFracCol);
	}
	return vec4(orbit, de_box(p, vec3(6.0)));
}

float de_marble(vec4 p) 
{
	return de_sphere(p - vec4(iMarblePos, 0), iMarbleRad);
}

vec4 col_marble(vec4 p) 
{
	vec4 col = vec4(0, 0, 0, de_sphere(p - vec4(iMarblePos, 0), iMarbleRad));
	return vec4(col.x, col.y, col.z, de_sphere(p - vec4(iMarblePos, 0), iMarbleRad));
}

float de_flag(vec4 p) 
{
	vec3 f_pos = iFlagPos + vec3(1.5, 4, 0)*iFlagScale;
	float d = de_box(p - vec4(f_pos, 0), vec3(1.5, 0.8, 0.08)*iMarbleRad);
	d = min(d, de_capsule(p - vec4(iFlagPos + vec3(0, iFlagScale*2.4, 0), 0), iMarbleRad*2.4, iMarbleRad*0.18));
	return d;
}

vec4 col_flag(vec4 p) 
{
	vec3 f_pos = iFlagPos + vec3(1.5, 4, 0)*iFlagScale;
	float d1 = de_box(p - vec4(f_pos, 0), vec3(1.5, 0.8, 0.08)*iMarbleRad);
	float d2 = de_capsule(p - vec4(iFlagPos + vec3(0, iFlagScale*2.4, 0), 0), iMarbleRad*2.4, iMarbleRad*0.18);
	if (d1 < d2) {
		return vec4(1.0, 0.2, 0.1, d1);
	} else {
		return vec4(0.9, 0.9, 0.1, d2);
	}
}

//float DE_count = 0;

float de_scene(vec3 pos) 
{
	//DE_count = DE_count+1;
	vec4 p = vec4(pos,1.f);
	float d = de_fractal(p);
	d = min(d, de_marble(p));
	d = min(d, de_flag(p));
	return d;
}

vec4 col_scene(vec3 pos) 
{
	//DE_count = DE_count+1;
	vec4 p = vec4(pos,1.f);
	vec4 col = col_fractal(p);
	vec4 col_f = col_flag(p);
	if (col_f.w < col.w) { col = col_f; }
	vec4 col_m = col_marble(p);
	if (col_m.w < col.w) {
		return vec4(col_m.xyz, 1.0);
	}
	return vec4(col.xyz, 0.0);
}


#define MAX_DIST 50
#define MIN_DIST 0.0001
#define MAX_MARCHES 192

void ray_march(inout vec4 pos, inout vec4 dir, inout vec4 var, float fov) 
{
	//March the ray
	pos.w = DE(pos.xyz);
	for (; var.x < MAX_MARCHES; var.x += 1.0) {
		dir.w += pos.w;
		pos.xyz += pos.w*dir.xyz;
		pos.w = DE(pos.xyz);
		
		//if the distance from the surface is less than the distance per pixel we stop
		if(pos.w < max(fov*dir.w, MIN_DIST) || dir.w > MAX_DIST )
		{
			break;
		}
	}
}

//better to use a sampler though
vec4 interp(layout (rgba32f) image2D text, vec2 coord)
{
	//coord *= 0.99;
	ivec2 ci = ivec2(coord);
	vec2 d = (coord - floor(coord));
	return imageLoad(text, ci)*(1-d.x)*(1-d.y) +
		   imageLoad(text, ci+ivec2(1,0))*d.x*(1-d.y) +
		   imageLoad(text, ci+ivec2(0,1))*(1-d.x)*d.y +
		   imageLoad(text, ci+ivec2(1))*d.x*d.y;
}

float sphere_intersection(vec3 r, vec3 p, vec4 sphere)
{
	p = sphere.xyz - p;
	if(p == vec3(0)) return sphere.w;
	
	r.x = dot(p, r);
	r.y = sphere.w*sphere.w - dot(r,r);
	r.z = r.x*r.x + r.y;
	
	if((r.z <= 0) || (r.y <= 0)) //if no intersection
	{
		return 0;
	}
	else
	{
		return sqrt(r.z) + r.x; //use furthest solution in the direction of the ray
	}
}

float find_furthest_intersection(vec3 r, vec3 p, ivec2 id)
{
	float d = 0;
	ivec2 idR = min(id+1, group_size);
	ivec2 idL = max(id-1, 0);
	for(int i = idL.x; i< idR.x; i++)
	{
		for(int j = idL.y; j < idR.y; j++)
		{
			d = max(d, sphere_intersection(r,p,de_sph[i][j]));
		}
	}
	return d;
}
/*
float divergence(in vec4 dir[bundle_length])
{
	return sqrt(1-pow(dot(dir[0], dir[bundle_length-1]),2));
}


void ray_bundle_marching1(inout vec4 pos[bundle_length], inout vec4 dir[bundle_length], inout vec4 var[bundle_length], int id)
{
	bool marching = true;
	float d = 0.f;
	
	//march central ray while safe to do so(ray bundle within ray cone)
	ray_march(pos[bundle_center], dir[bundle_center], var[bundle_center], divergence(dir));
	
	pos[bundle_center].w = 0;
	#pragma unroll
	for(int i = bundle_center+1, ii = i; i < bundle_length+bundle_center; ii = ++i%bundle_length)
	{
		pos[ii].xyz += dir[ii].xyz*dir[bundle_center].w;
		dir[ii].w = dir[bundle_center].w;
		var[ii] = var[bundle_center];
	}

	vec4 sphere = vec4(0);
	for(int m = 0; (m < MAX_MARCHES -var[bundle_center].x ) && marching; m++)
	{
		marching = false;
		sphere.w = 0;
		for(int i = 0; i < bundle_length; i++)
		{
			if((dir[i].w > MAX_DIST || (pos[i].w < fovray*dir[i].w &&  pos[i].w > 0)) && (dir[i].w > 0))
			{
				continue;
			}
			else
			{
				marching = true;
			}

			
			pos[i].xyz += dir[i].xyz*pos[i].w;
			dir[i].w += pos[i].w;
			var[i].x += 1.f;
			
			//memoryBarrierShared();
			d = sphere_intersection(dir[i].xyz, pos[i].xyz, sphere);
			
			if(d < fovray*dir[i].w)
			{
				pos[i].w = DE(pos[i].xyz);
				if(sphere.w < pos[i].w)
				{
					sphere = pos[i];
				}
			}
			else //if found a usable DE
			{
				pos[i].w = d;
			}
		}
	}
}*/


///The second step of multi resolution ray marching

void main() {
	ivec2 global_pos = ivec2(gl_GlobalInvocationID.xy);
	ivec2 local_indx = ivec2(gl_LocalInvocationID.xy);
	vec2 img_size = vec2(imageSize(DE_output));
	vec2 pimg_size = vec2(imageSize(DE_input));
	vec2 MRRM_step_scale = img_size/pimg_size;
	//if within the texture
	
	ivec2 prev_pos = min(ivec2((vec2(global_pos)/MRRM_step_scale) + 0.5),ivec2(pimg_size)-1);
	//initialize the ray
	de_sph[local_indx.x][local_indx.y] = imageLoad(DE_input, prev_pos);
	memoryBarrierShared();
	 
	ray rr = get_ray(vec2(global_pos)/img_size);
	vec4 pos = vec4(rr.pos,0);
	vec4 dir = vec4(rr.dir,0);
	vec4 var = vec4(0);
		
	float td = length(pos.xyz - de_sph[local_indx.x][local_indx.y].xyz);//traveled distance
	
	//first order, MRRM
	pos.xyz += dir.xyz*td;//move local ray beginning inside the DE sphere;
	dir.w += td;
	
	//calculate new best pos, second order, MRRBM
	barrier();
	float d = find_furthest_intersection(dir.xyz, pos.xyz, local_indx);
	
	pos.xyz += dir.xyz*d; //move the ray beginning to the furthest sphere intersection
	dir.w += d;
	
	fovray = 2.5*Camera.FOV/img_size.x;
	
	ray_march(pos, dir, var, fovray);

	vec4 var = interp(var_input, vec2(global_pos)/MRRM_step_scale);
	//save the DE sphere
	imageStore(DE_output, global_pos, pos);	  
	imageStore(var_output, global_pos, var);		
}

ERROR: 0:401: 'var' : redefinition 

