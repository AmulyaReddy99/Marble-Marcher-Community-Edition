#version 430
//4*4 ray bundle
#define bundle_size 1
#define bundle_length 1
#define bundle_center 0
#define group_size 8
#define block_size 64
#define RBM 0

struct ray
{
	vec3 pos;
	vec3 dir;
};		

struct gl_camera
{
	vec3 position;
	vec3 dirx;
	vec3 diry;
	vec3 dirz;
	vec2 resolution;
	float aspect_ratio;
	float FOV;
	float focus;
	float bokeh;
	float exposure;
	float mblur;
	float speckle;
	float size;
	int stepN;
	int step;
};


ivec2 getGpos(int index)
{
	int y = index/group_size;
	int x = index%group_size;
	return ivec2(x,y);
}

uniform gl_camera Camera;
float fovray;

ray get_ray(vec2 screen_pos)
{
	vec2 shift = Camera.FOV*(2.f*screen_pos - 1.f)*vec2(Camera.aspect_ratio, 1.f);
	ray cray;
	cray.pos = Camera.position;
	cray.dir = normalize(Camera.dirx*shift.x + Camera.diry*shift.y + Camera.dirz);
	fovray = Camera.FOV/Camera.resolution.x; //pixel FOV
	return cray;
}


//4*4 bundle of ray bundles(oh lol)
layout(local_size_x = group_size, local_size_y = group_size) in;
layout(rgba8, binding = 0) uniform image2D img_output;

//make all the local distance estimator spheres shared
shared vec4 de_sph[block_size]; 
#define COL col_scene
#define DE de_scene

uniform float iFracScale;
uniform float iFracAng1;
uniform float iFracAng2;
uniform vec3 iFracShift;
uniform vec3 iFracCol;
uniform vec3 iMarblePos;
uniform float iMarbleRad;
uniform float iFlagScale;
uniform vec3 iFlagPos;
#define FRACTAL_ITER 16

///Original MM distance estimators

float s1 = sin(iFracAng1), c1 = cos(iFracAng1), s2 = sin(iFracAng2), c2 = cos(iFracAng2);

//##########################################
//   Space folding
//##########################################
void planeFold(inout vec4 z, vec3 n, float d) {
	z.xyz -= 2.0 * min(0.0, dot(z.xyz, n) - d) * n;
}
void sierpinskiFold(inout vec4 z) {
	z.xy -= min(z.x + z.y, 0.0);
	z.xz -= min(z.x + z.z, 0.0);
	z.yz -= min(z.y + z.z, 0.0);
}
void mengerFold(inout vec4 z) {
	float a = min(z.x - z.y, 0.0);
	z.x -= a;
	z.y += a;
	a = min(z.x - z.z, 0.0);
	z.x -= a;
	z.z += a;
	a = min(z.y - z.z, 0.0);
	z.y -= a;
	z.z += a;
}
void boxFold(inout vec4 z, vec3 r) {
	z.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;
}
void rotX(inout vec4 z, float s, float c) {
	z.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);
}
void rotY(inout vec4 z, float s, float c) {
	z.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);
}
void rotZ(inout vec4 z, float s, float c) {
	z.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);
}
void rotX(inout vec4 z, float a) {
	rotX(z, sin(a), cos(a));
}
void rotY(inout vec4 z, float a) {
	rotY(z, sin(a), cos(a));
}
void rotZ(inout vec4 z, float a) {
	rotZ(z, sin(a), cos(a));
}

//##########################################
//   Primitive DEs
//##########################################
float de_sphere(vec4 p, float r) {
	return (length(p.xyz) - r) / p.w;
}
float de_box(vec4 p, vec3 s) {
	vec3 a = abs(p.xyz) - s;
	return (min(max(max(a.x, a.y), a.z), 0.0) + length(max(a, 0.0))) / p.w;
}
float de_tetrahedron(vec4 p, float r) {
	float md = max(max(-p.x - p.y - p.z, p.x + p.y - p.z),
				max(-p.x + p.y + p.z, p.x - p.y + p.z));
	return (md - r) / (p.w * sqrt(3.0));
}
float de_capsule(vec4 p, float h, float r) {
	p.y -= clamp(p.y, -h, h);
	return (length(p.xyz) - r) / p.w;
}

//##########################################
//   Main DEs
//##########################################
float de_fractal(vec4 p)
{
	for (int i = 0; i < FRACTAL_ITER; ++i) {
		p.xyz = abs(p.xyz);
		rotZ(p, s1, c1);
		mengerFold(p);
		rotX(p, s2, c2);
		p *= iFracScale;
		p.xyz += iFracShift;
	}
	return de_box(p, vec3(6.0));
}

vec4 col_fractal(vec4 p) 
{
	vec3 orbit = vec3(0.0);
	for (int i = 0; i < FRACTAL_ITER; ++i) {
		p.xyz = abs(p.xyz);
		rotZ(p, s1, c1);
		mengerFold(p);
		rotX(p, s2, c2);
		p *= iFracScale;
		p.xyz += iFracShift;
		orbit = max(orbit, p.xyz*iFracCol);
	}
	return vec4(orbit, de_box(p, vec3(6.0)));
}

float de_marble(vec4 p) 
{
	return de_sphere(p - vec4(iMarblePos, 0), iMarbleRad);
}

vec4 col_marble(vec4 p) 
{
	vec4 col = vec4(0, 0, 0, de_sphere(p - vec4(iMarblePos, 0), iMarbleRad));
	return vec4(col.x, col.y, col.z, de_sphere(p - vec4(iMarblePos, 0), iMarbleRad));
}

float de_flag(vec4 p) 
{
	vec3 f_pos = iFlagPos + vec3(1.5, 4, 0)*iFlagScale;
	float d = de_box(p - vec4(f_pos, 0), vec3(1.5, 0.8, 0.08)*iMarbleRad);
	d = min(d, de_capsule(p - vec4(iFlagPos + vec3(0, iFlagScale*2.4, 0), 0), iMarbleRad*2.4, iMarbleRad*0.18));
	return d;
}

vec4 col_flag(vec4 p) 
{
	vec3 f_pos = iFlagPos + vec3(1.5, 4, 0)*iFlagScale;
	float d1 = de_box(p - vec4(f_pos, 0), vec3(1.5, 0.8, 0.08)*iMarbleRad);
	float d2 = de_capsule(p - vec4(iFlagPos + vec3(0, iFlagScale*2.4, 0), 0), iMarbleRad*2.4, iMarbleRad*0.18);
	if (d1 < d2) {
		return vec4(1.0, 0.2, 0.1, d1);
	} else {
		return vec4(0.9, 0.9, 0.1, d2);
	}
}

//float DE_count = 0;

float de_scene(vec3 pos) 
{
	//DE_count = DE_count+1;
	vec4 p = vec4(pos,1.f);
	float d = de_fractal(p);
	d = min(d, de_marble(p));
	d = min(d, de_flag(p));
	return d;
}

vec4 col_scene(vec3 pos) 
{
	//DE_count = DE_count+1;
	vec4 p = vec4(pos,1.f);
	vec4 col = col_fractal(p);
	vec4 col_f = col_flag(p);
	if (col_f.w < col.w) { col = col_f; }
	vec4 col_m = col_marble(p);
	if (col_m.w < col.w) {
		return vec4(col_m.xyz, 1.0);
	}
	return vec4(col.xyz, 0.0);
}


#define MAX_DIST 50
#define MIN_DIST 0.0001
#define MAX_MARCHES 196

void ray_march(inout vec4 pos, inout vec4 dir, inout vec4 var, float fov) 
{
	//March the ray
	float s = 0;
	pos.w = DE(pos.xyz);
	
	for (; s < MAX_MARCHES; s += 1.0) {
		dir.w += pos.w;
		pos.xyz += pos.w*dir.xyz;
		pos.w = DE(pos.xyz);
		
		//if the distance from the surface is less than the distance per pixel we stop
		if(pos.w < max(fov*dir.w, MIN_DIST) || dir.w > MAX_DIST )
		{
			break;
		}
	}
	var.x = s;
}


float sphere_intersection(vec3 r, vec3 p, vec4 sphere)
{
	p = sphere.xyz - p;
	if(p == vec3(0)) return sphere.w;
	
	r.x = dot(p, r);
	r.y = sphere.w*sphere.w - dot(r,r);
	r.z = r.x*r.x + r.y;
	
	if((r.z <= 0) || (r.y <= 0)) //if no intersection
	{
		return 0;
	}
	else
	{
		return sqrt(r.z) + r.x; //use furthest solution in the direction of the ray
	}
}

float find_furthest_intersection(vec3 r, vec3 p, ivec2 id)
{
	float d = 0;
	ivec2 idR = min(id+1, group_size);
	ivec2 idL = max(id-1, 0);
	for(int i = idL.x; i< idR.x; i++)
	{
		for(int j = idL.y; j < idR.y; j++)
		{
			d = max(d, sphere_intersection(r,p,de_sph[i][j]));
		}
	}
	return d;
}
/*
float divergence(in vec4 dir[bundle_length])
{
	return sqrt(1-pow(dot(dir[0], dir[bundle_length-1]),2));
}


void ray_bundle_marching1(inout vec4 pos[bundle_length], inout vec4 dir[bundle_length], inout vec4 var[bundle_length], int id)
{
	bool marching = true;
	float d = 0.f;
	
	//march central ray while safe to do so(ray bundle within ray cone)
	ray_march(pos[bundle_center], dir[bundle_center], var[bundle_center], divergence(dir));
	
	pos[bundle_center].w = 0;
	#pragma unroll
	for(int i = bundle_center+1, ii = i; i < bundle_length+bundle_center; ii = ++i%bundle_length)
	{
		pos[ii].xyz += dir[ii].xyz*dir[bundle_center].w;
		dir[ii].w = dir[bundle_center].w;
		var[ii] = var[bundle_center];
	}

	vec4 sphere = vec4(0);
	for(int m = 0; (m < MAX_MARCHES -var[bundle_center].x ) && marching; m++)
	{
		marching = false;
		sphere.w = 0;
		for(int i = 0; i < bundle_length; i++)
		{
			if((dir[i].w > MAX_DIST || (pos[i].w < fovray*dir[i].w &&  pos[i].w > 0)) && (dir[i].w > 0))
			{
				continue;
			}
			else
			{
				marching = true;
			}

			
			pos[i].xyz += dir[i].xyz*pos[i].w;
			dir[i].w += pos[i].w;
			var[i].x += 1.f;
			
			//memoryBarrierShared();
			d = sphere_intersection(dir[i].xyz, pos[i].xyz, sphere);
			
			if(d < fovray*dir[i].w)
			{
				pos[i].w = DE(pos[i].xyz);
				if(sphere.w < pos[i].w)
				{
					sphere = pos[i];
				}
			}
			else //if found a usable DE
			{
				pos[i].w = d;
			}
		}
	}
}*/



//each shader invocation will march a ray bundle,
//all invocations will have all the DE data from neighbore
//ray bundles to improve marching efficiency
//since it will give a larger volume of space in which the rays can safely march
//(not only a single DE sphere)

void main() {
	ivec2 global_pos = ivec2(gl_GlobalInvocationID.x,gl_GlobalInvocationID.y);
	int local_indx = int(gl_LocalInvocationIndex);
	ivec2 block_pos = bundle_size*global_pos;
	vec2 img_size = vec2(imageSize(img_output));
	if(block_pos.x < img_size.x && block_pos.y < img_size.y)
	{
		//ray bundle array
		vec4 pos[bundle_length];
		vec4 dir[bundle_length];
		vec4 var[bundle_length];
		
		//initialize the ray bundle
		ivec2 pix = block_pos;
		#pragma unroll
		for(int i = 0; i < bundle_length; i++)
		{	
			ray rr = get_ray(vec2(pix)/img_size);
			pos[i] = vec4(rr.pos,0);
			dir[i] = vec4(rr.dir,0);
			var[i] = vec4(0);
		}
		
		//de_sph[local_indx] = pos[bundle_center]; 
		
	
		#pragma unroll
		for(int i = 0; i < bundle_length; i++)
		{
			ray_march(pos[i], dir[i], var[i], fovray);
		}
		
		// output to the specified image block
		
		pix = block_pos;
		#pragma unroll
		for(int i = 0; i < bundle_length; i++)
		{	
			//ray rr = get_ray(vec2(pix)/vec2(imageSize(img_output)));
			
		/*	pos[i] = vec4(rr.pos,0);
			dir[i] = vec4(rr.dir,0);
			ray_march(pos[i], dir[i]);*/
		//	float DE_per_pix = DE_count/float(bundle_length*MAX_MARCHES);
			float ao = (1 -  var[i].x/MAX_MARCHES);
			float td = (1 - dir[i].w*0.06f);
			//memoryBarrierImage();
			imageStore(img_output, pix, vec4(ao,ao,ao,1));	  
		}
	}
}

ERROR: 0:288: 'sphere_intersection' : no matching overloaded function found (using implicit conversion) 

